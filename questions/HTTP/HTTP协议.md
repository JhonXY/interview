## 概述

HTTP (超文本传输协议) 是用来在 Web 上传输文件的基础 协议 。HTTP 是基于文本 (所有的通信都是以纯文本的形式进行) 以及无状态的 (当前通信不会发现以前的通信状态)。

HTTP是一种能够获取如 HTML 这样的网络资源的 protocol(通讯协议)。它是在 Web 上进行数据交换的基础，是一种 client-server 协议，也就是说，请求通常是由像浏览器这样的接受方发起的。一个完整的Web文档通常是由不同的子文档拼接而成的，像是文本、布局描述、图片、视频、脚本等等。

## 基于HTTP的组件系统

请求通过一个实体被发出，实体也就是用户代理。大多数情况下，这个用户代理都是指浏览器，也可能是任何东西，比如一个爬取网页的机器爬虫。

每一个发送到服务器的请求，都会被处理并返回一个response。在这个请求与回应之间，还有许许多多的被称为proxies（代理）的实体，他们的作用与表现各不同，如有些是网关，还有些是caches等。

----

实际在一个浏览器和处理请求的服务器之间，还有路由器、调制解调器等许多计算机。由于Web的层次设计，那些在网络层和传输层的细节都被隐藏起来了。HTTP位于最上层的应用层。虽然底层对于分析网络问题非常重要，但是大多都跟对HTTP的描述不相干。


#### 代理（Proxies）

代理（Proxies）既可以表现得透明，又可以不透明（“改变请求”不会通过它们）。代理主要有如下几种作用：

- 缓存（可以是公开的也可以是私有的，像浏览器的缓存）
- 过滤（像反病毒扫描，家长控制...）
- 负载均衡（让多个服务器服务不同的请求）
- 认证（对不同资源进行权限管理）
- 日志记录（允许存储历史信息）

> ### 网关
> 
> API 网关是介于客户端和服务器端之间的中间层，所有的外部请求都会先经过 API 网关这一层。也就是说，API 的实现方面更多的考虑业务逻辑，而安全、性能、监控可以交由 API 网关来做，这样既提高业务灵活性又不缺安全性。
> 
> API 网关出现的原因是微服务架构的出现，不同的微服务一般会有不同的网络地址，而外部客户端可能需要调用多个服务的接口才能完成一个业务需求，如果让客户端直接与各个微服务通信，会有以下的问题：
> 1. 客户端会多次请求不同的微服务，增加了客户端的复杂性。
> 2. 存在跨域请求，在一定场景下处理相对复杂。
> 3. 认证复杂，每个服务都需要独立认证。
> 4. 难以重构，随着项目的迭代，可能需要重新划分微服务。例如，可能将多个服务合并成一个或者将一个服务拆分成多个。如果客户端直接与微服务通信，那么重构将会很难实施。
> 5. 某些微服务可能使用了防火墙 / 浏览器不友好的协议，直接访问会有一定的困难。
> 详细[查看](https://www.sohu.com/a/221110905_467759)


## 性质

**简单、可扩展、无状态，有会话**

虽然下一代HTTP/2协议将HTTP消息封装到了帧（frames）中，HTTP大体上还是被设计得简单易读。HTTP报文能够被人读懂，还允许简单测试，降低了门槛，对新人很友好。

在 HTTP/1.0 中出现的 HTTP headers 让协议扩展变得非常容易。只要服务端和客户端就新 headers 达成语义一致，新功能就可以被轻松加入进来。

HTTP本质是无状态的，在同一个连接中，两个执行成功的请求之间是没有关系的，使用Cookies可以创建有状态的会话。

## HTTP大致流程

1. 打开一个TCP连接：TCP连接被用来发送一条或多条请求，以及接受回应消息。客户端可能打开一条新的连接，或重用一个已经存在的连接，或者也可能开几个新的TCP连接连向服务端。

2. 发送一个HTTP报文：HTTP报文（在HTTP/2之前）是语义可读的。在HTTP/2中，这些简单的消息被封装在了帧中，这使得报文不能被直接读取，但是原理仍是相同的。
3. 读取服务端返回的报文信息：
4. 关闭连接或者为后续请求重用连接。

## HTTP报文

#### 请求

![请求](https://mdn.mozillademos.org/files/13687/HTTP_Request.png)

请求主要由以下元素组成:

- `Method` 一个动词像GET, POST 或者一个名词像OPTIONS，HEAD来定义客户端的动作行为。通常客户端的操作都是获取资源（GET方法）或者发送HTML form表单值（POST方法），虽然在一些情况下也会有其他操作。
- `Path` 一个动词像GET, POST 或者一个名词像OPTIONS，HEAD来定义客户端的动作行为。通常客户端的操作都是获取资源（GET方法）或者发送HTML form表单值（POST方法），虽然在一些情况下也会有其他操作。
- HTTP版本号。
- `Headers` 为服务端表达其他信息的可选头部headers。
- 对于一些像POST这样的方法，报文的body就包含了发送的资源，这与回应报文的body类似。

#### 回应

![回应](https://mdn.mozillademos.org/files/13691/HTTP_Response.png)

回应报文包含了下面的元素：

- HTTP协议版本号.
- 一个状态码（status code），来告知对应请求执行成功或失败，以及失败的原因。
- 一个状态信息，这个信息是非权威的状态码描述信息，可以由服务端自行设定。
- `Headers`  headers，与请求头部类似。
- 可选项，比起请求报文，响应报文中更常见地包含获取的资源body。


> 更加详细的HTTP信息查看[MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTTP)